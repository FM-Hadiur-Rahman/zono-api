enum AttendanceStatus {
  working // clocked-in, not yet out
  present // clocked in & out
  late // started after shift start + grace
  left_early // left before shift end - grace
  absent // no show (set by rule or admin)
}

model AttendanceEvent {
  id          String           @id @default(cuid())
  tenantId    String
  employeeId  String
  shiftId     String?
  date        DateTime // normalized to 00:00 of local tz
  clockInAt   DateTime?
  clockInSrc  String? // 'web', 'kiosk', 'mobile'
  clockInLat  Float?
  clockInLng  Float?
  clockOutAt  DateTime?
  clockOutSrc String?
  clockOutLat Float?
  clockOutLng Float?
  minutes     Int? // computed on clock-out
  status      AttendanceStatus @default(working)
  notes       String?

  employee Employee @relation(fields: [employeeId], references: [id])
  tenant   Tenant   @relation(fields: [tenantId], references: [id])
  shift    Shift?   @relation(fields: [shiftId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, employeeId, date]) // one row per day
  @@index([tenantId, date])
  @@index([employeeId, date])
}

model AuditLog {
  id       String   @id @default(cuid())
  tenantId String
  userId   String?
  action   String
  entity   String
  entityId String?
  before   Json?
  after    Json?
  ts       DateTime @default(now())
  tenant   Tenant   @relation(fields: [tenantId], references: [id])
}

// prisma/schema/availability.prisma
model Availability {
  id         String   @id @default(cuid())
  tenantId   String
  employeeId String
  date       DateTime // normalized to midnight (tenant TZ ideally)
  start      String // "HH:mm"
  end        String // "HH:mm"
  note       String? // optional notes
  createdAt  DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id])

  @@index([tenantId, employeeId, date])
  @@index([tenantId, date])
}

generator client {
  provider        = "prisma-client-js"
  binaryTargets   = ["native", "debian-openssl-3.0.x"]
  previewFeatures = ["prismaSchemaFolder"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Employee {
  id         String  @id @default(cuid())
  tenantId   String
  userId     String // if you’re doing the user link
  locationId String?
  name       String
  role       String
  status     String  @default("Available")

  tenant   Tenant    @relation(fields: [tenantId], references: [id])
  location Location? @relation(fields: [locationId], references: [id])
  user     User?     @relation(fields: [userId], references: [id])

  shifts       Shift[]
  events       AttendanceEvent[]
  availability Availability[]
  swapsFrom    ShiftSwap[]       @relation("SwapFrom") // back-rel
  swapsTo      ShiftSwap[]       @relation("SwapTo") // back-rel
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@unique([tenantId, userId])
  @@index([tenantId, userId])
}

model FeatureFlag {
  id       String  @id @default(cuid())
  tenantId String
  key      String
  enabled  Boolean @default(false)
  tenant   Tenant  @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, key])
}

model InventoryItem {
  id                String           @id @default(cuid())
  tenantId          String
  locationId        String?
  name              String
  sku               String?          @unique
  lowStockThreshold Int              @default(0)
  tenant            Tenant           @relation(fields: [tenantId], references: [id])
  location          Location?        @relation(fields: [locationId], references: [id])
  levels            InventoryLevel[]
  alerts            LowStockAlert[]
}

model InventoryLevel {
  id         String        @id @default(cuid())
  tenantId   String
  itemId     String
  qtyOnHand  Int           @default(0)
  updatedAt  DateTime      @default(now())
  tenant     Tenant        @relation(fields: [tenantId], references: [id])
  item       InventoryItem @relation(fields: [itemId], references: [id])
  locationId String?
  location   Location?     @relation(fields: [locationId], references: [id])
}

model LowStockAlert {
  id         String        @id @default(cuid())
  tenantId   String
  itemId     String
  level      Int
  createdAt  DateTime      @default(now())
  resolvedAt DateTime?
  tenant     Tenant        @relation(fields: [tenantId], references: [id])
  item       InventoryItem @relation(fields: [itemId], references: [id])
}

model Notification {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String
  type      String // e.g. "shift.created"
  title     String
  body      String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([tenantId, userId, isRead, createdAt])
}

// prisma/schema/shiftSwap.prisma

enum ShiftSwapStatus {
  pending_target
  pending_manager
  approved
  declined
  cancelled
}

model ShiftSwap {
  id              String          @id @default(cuid())
  tenantId        String
  shiftId         String
  fromEmployeeId  String
  toEmployeeId    String
  status          ShiftSwapStatus @default(pending_target)
  reason          String?
  decidedAt       DateTime?
  decidedByUserId String?
  createdAt       DateTime        @default(now())

  // forward relations
  shift        Shift    @relation(fields: [shiftId], references: [id])
  fromEmployee Employee @relation("SwapFrom", fields: [fromEmployeeId], references: [id])
  toEmployee   Employee @relation("SwapTo", fields: [toEmployeeId], references: [id])

  @@index([tenantId, shiftId])
  @@index([tenantId, toEmployeeId, status])
}

model Shift {
  id         String   @id @default(cuid())
  tenantId   String
  employeeId String
  date       DateTime // normalized to midnight
  start      String // "HH:mm"
  end        String
  role       String   @default("Staff")
  tenant     Tenant   @relation(fields: [tenantId], references: [id])

  employee        Employee          @relation(fields: [employeeId], references: [id])
  swapRequests    ShiftSwap[]
  AttendanceEvent AttendanceEvent[]

  @@index([tenantId, date])
  @@index([tenantId, employeeId, date])
}

model Tenant {
  id         String            @id @default(cuid())
  name       String
  subdomain  String            @unique // ✅ required by your controller
  plan       String            @default("Standard")
  status     String            @default("active")
  createdAt  DateTime          @default(now())
  locations  Location[]
  users      User[]
  employees  Employee[]
  shifts     Shift[]
  attendance AttendanceEvent[]
  items      InventoryItem[]
  levels     InventoryLevel[]
  alerts     LowStockAlert[]
  features   FeatureFlag[]
  audits     AuditLog[]

  // if you added invitations:
  invitations Invitation[]
}

model Location {
  id        String           @id @default(cuid())
  tenantId  String
  name      String
  timezone  String           @default("Europe/Berlin")
  tenant    Tenant           @relation(fields: [tenantId], references: [id])
  employees Employee[]
  items     InventoryItem[]
  levels    InventoryLevel[]
}

model User {
  id              String     @id @default(cuid())
  email           String     @unique
  passwordHash    String
  role            String
  tenantId        String?
  tenant          Tenant?    @relation(fields: [tenantId], references: [id])
  createdAt       DateTime   @default(now())
  emailVerifiedAt DateTime?
  phone           String?
  country         String?
  // you already had this
  employees       Employee[]

  // ✅ back-relation to EmailVerificationToken
  emailVerificationTokens EmailVerificationToken[] @relation("UserEmailVerificationTokens")
}

model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  // ✅ forward side with the SAME relation name
  user User @relation("UserEmailVerificationTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Invitation {
  id         String    @id @default(cuid())
  tenantId   String
  email      String
  role       String
  token      String    @unique
  expiresAt  DateTime
  acceptedAt DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}
